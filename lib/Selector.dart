import 'dart:collection';

enum SelectorMode {
  multiple,
  sameGroup,
  single,
}

class Selector<T> {
  /// To translate [T] into index in [String].
  String Function(T) indexGetter;

  /// To translate [T] into groupName in [String].
  late String Function(T) groupNameGetter;

  /// Index (as generated by [indexGetter]) as key and groupName (as generated by [groupNameGetter]) as value.
  late LinkedHashMap<String, String> _groups;

  /// Index (as generated by [indexGetter]) as key and option<[T]> as value.
  late LinkedHashMap<String, T> _options;

  /// Containing selected indexes. Might ordered differently from [_options.keys].
  late Set<String> _selected;

  /// Save [initialSelected] and doesn't change.
  late final Set<String> _originalSelected;

  /// Selector runtime mode.
  final SelectorMode mode;

  /// Initiate a [Selector].
  ///
  /// This selector will allow you to choose options<[T]> on [choosableOptions].
  ///
  /// Each [T] must somehow can be identified uniqly as a [String] (index).
  /// Specify how that identification is done on [indexGetter].
  ///
  /// Use [initialSelected] to define pre-selected index.
  ///
  /// You can also groups options<[T]> by some [String] identification (like index)
  /// which you can specify on [groupNameGetter].
  ///
  /// [mode] can be:
  /// - [SelectorMode.multiple] (default)
  /// - [SelectorMode.sameGroup]: allow selection on multiple options but must be on the same group.
  /// Selected options on other group will be unselected when you select an option on not currently selected group.
  /// - [SelectorMode.single]: only allow 1 option to be selected.
  Selector({
    required this.indexGetter,
    required Iterable<T> choosableOptions,
    String Function(T)? groupNameGetter,
    Iterable<String>? initialSelected,
    this.mode = SelectorMode.multiple,
  }) {
    assert(T is! String);

    // fill default
    this.groupNameGetter = groupNameGetter ?? (t) => 'noGroup';
    _selected = Set.from(initialSelected ?? <String>[]);

    _init(choosableOptions);

    _originalSelected = Set.from(_constrainedSelected());
    // constraint only done at runtime
  }

  void _init(Iterable<T> choosableOptions) {
    // build group index
    _groups = LinkedHashMap<String, String>.fromIterable(
      choosableOptions,
      key: (o) => indexGetter(o),
      value: (o) => groupNameGetter(o),
    );

    // save to options
    _options = LinkedHashMap<String, T>.fromIterable(
      choosableOptions,
      key: (o) => indexGetter(o),
      value: (o) => o,
    );
  }

  /// Return new [Selector] initialized with same arguments.
  /// You can change into [newMode].
  Selector<T> clone({SelectorMode? newMode}) {
    Selector<T> a = Selector(
      indexGetter: indexGetter,
      choosableOptions: _options.values,
      groupNameGetter: groupNameGetter,
      initialSelected: _constrainedSelected(forceMode: newMode),
      mode: newMode ?? mode,
    );
    return a;
  }

  /// If currently all options are selected ([isAllSelected] returns true),
  /// that state will be preserved. If not, what currently selected will stay the same.
  void updateOptions(Iterable<T> choosableOptions) {
    if (isAllSelected) {
      _selected = Set.from(choosableOptions.map(indexGetter));
    }
    _init(choosableOptions);
  }

  /// This will return [_selected] that exists in [_options.keys], ordered as [_options.keys].
  Iterable<String> get _sortedSelected =>
      _options.keys.where((k) => _selected.contains(k));

  /// This will return [_sortedSelected] with constraint applied (as described by [mode] or [forceMode] if defined).
  Iterable<String> _constrainedSelected({SelectorMode? forceMode}) {
    if (isNoneSelected) return [];

    forceMode ??= mode;

    Iterable<String> selected = _sortedSelected;
    if (forceMode == SelectorMode.single) {
      // only returns first selected
      return [selected.first];
    } else if (forceMode == SelectorMode.sameGroup) {
      // only returns from first group
      String? groupName = _groups[selected.first];
      return selected.where((i) => _groups[i] == groupName);
    }
    return selected;
  }

  /// Return true if all options are selected.
  bool get isAllSelected =>
      _constrainedSelected().length == _options.keys.length;

  /// Return true if no option selected at all.
  bool get isNoneSelected => _sortedSelected.isEmpty;

  /// Do nothing if [mode] is [SelectorMode.single].
  ///
  /// When [mode] is [SelectorMode.sameGroup], this method will only work when there is only 1 group exists.
  /// If there is more than 1 groups, this method will do nothing.
  void selectAll() {
    if (mode == SelectorMode.single) return;
    if (mode == SelectorMode.sameGroup && groups.length > 1) return;
    _selected = Set.from(_options.keys);
  }

  /// Will unselect all options.
  void unselectAll() {
    _selected.clear();
  }

  /// Do [unselectAll] when [isAllSelected] is true. Else, will do [selectAll].
  void toggleAll() {
    if (isAllSelected) {
      return unselectAll();
    } else {
      return selectAll();
    }
  }

  /// Check selection status of an option. Return true if the option selected.
  /// Which option to check can be defined by the index ([String]) or by the option ([T]) object itself.
  ///
  /// This will check and enforce [mode] constraint.
  bool isSelected(dynamic o) {
    assert(o is String || o is T);
    if (o is T) o = indexGetter(o);

    return _constrainedSelected().contains(o);
  }

  /// Change the option status to be selected.
  /// Which option to select can be defined by the index ([String]) or by the option ([T]) object itself.
  ///
  /// Will clear and select [o] when [mode] is [SelectorMode.single].
  /// When [mode] is [SelectorMode.sameGroup], will clear and select [o] if the group for this [o] is not currently selected.
  void select(dynamic o) {
    assert(o is String || o is T);
    if (o is T) o = indexGetter(o);

    if (mode == SelectorMode.single) {
      _selected = {o};
    } else if (mode == SelectorMode.sameGroup) {
      if (isGroupSelected(_groups[o])) {
        _selected.add(o);
      } else {
        // switch group
        _selected = {o};
      }
    } else {
      _selected.add(o);
    }
  }

  /// Change the option status to be unselected.
  /// Which option to unselect can be defined by the index ([String]) or by the option ([T]) object itself.
  ///
  /// Will do nothing if [mode] is [SelectorMode.single] as you should just select another option when on this [mode].
  void unselect(dynamic o) {
    assert(o is String || o is T);
    if (o is T) o = indexGetter(o);

    if (mode == SelectorMode.single) return;
    _selected.remove(o);
  }

  /// Change the option status (depending on [isSelected] result).
  /// Which option to be toggled can be defined by the index ([String]) or by the option ([T]) object itself.
  ///
  /// On [SelectorMode.single], this will just call [select].
  void toggle(dynamic o) {
    if (mode == SelectorMode.single) {
      select(o);
    } else if (isSelected(o)) {
      unselect(o);
    } else {
      select(o);
    }
  }

  /// Return all options that currently selected.
  Set<T> get selected {
    return _constrainedSelected().map((k) => _options[k]!).toSet();
  }

  /// Check if there any changes in selection.
  ///
  /// Compare [_originalSelected] with [_constrainedSelected].
  /// Based on length and two way containsAll check.
  bool isChanged() {
    if (_originalSelected.length != _constrainedSelected().length) return true;
    if (!_originalSelected.containsAll(_constrainedSelected())) return true;
    if (!_constrainedSelected().toSet().containsAll(_originalSelected))
      return true;
    return false;
  }

  /// Select all options in a group (defined by [groupName]).
  ///
  /// Wont work when [mode] is [SelectorMode.single].
  void selectGroup(String groupName) {
    if (mode == SelectorMode.single) return;
    if (mode == SelectorMode.sameGroup) _selected.clear();
    _selected.addAll(_groups.keys.where((i) => _groups[i] == groupName));
  }

  /// Unselect all options in a group.
  void unselectGroup(String groupName) {
    _selected.removeWhere((i) => _groups[i] == groupName);
  }

  /// Check if there is at least one option selected in a group.
  bool isGroupSelected(String? groupName) {
    for (String i in _constrainedSelected()) {
      if (_groups[i] == groupName) return true;
    }
    return false;
  }

  /// Check if all options are selected in a group.
  bool isGroupSelectedAll(String groupName) {
    Set<String> target =
        _groups.keys.where((i) => _groups[i] == groupName).toSet();
    if (target.isEmpty) return false;
    return _constrainedSelected().toSet().containsAll(target);
  }

  /// Calling [unselectGroup] or [selectGroup] depending on [isGroupSelectedAll] result.
  void toggleGroup(String groupName) {
    if (isGroupSelectedAll(groupName)) {
      unselectGroup(groupName);
    } else {
      selectGroup(groupName);
    }
  }

  /// Return groupName(s) where there is at least one option on that group that selected.
  /// Based on [isGroupSelected].
  Set<String> getGroupsWhereSelected() {
    Set<String> distinctGroupName = Set.from(_groups.values);
    return distinctGroupName.where((gn) => isGroupSelected(gn)).toSet();
  }

  /// Return groupName(s) where all options on that group are selected.
  /// Based on [isGroupSelectedAll].
  Set<String> getGroupsWhereSelectedAll() {
    Set<String> distinctGroupName = Set.from(_groups.values);
    return distinctGroupName.where((gn) => isGroupSelectedAll(gn)).toSet();
  }

  /// Return all selected options in a group.
  Set<T> getSelectedInGroup(String groupName) {
    return selected.where((o) => groupNameGetter(o) == groupName).toSet();
  }

  /// Return all options on a group.
  Set<T> getOptionsOnGroup(String groupName) {
    return _options.values
        .where((o) => groupNameGetter(o) == groupName)
        .toSet();
  }

  Set<T> get options => Set.from(_options.values);

  /// Get all the groupName (as generated by [groupNameGetter]).
  Set<String> get groups => _groups.values.toSet();
}
